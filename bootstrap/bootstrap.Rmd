This section will compare the single execution of a networkreconstruction technique to a bootstrapped execution. The single execution will use all 100% of the samples in its construction, whereas the bootstrapped version will only use 70% each iteration.

We'll first define the function that will give us the resultant network from a single iteration of 100% and a series of smaller iterations at 70%.

```{r}
#' Create a data.frame storing one single iteration of the selecte method along with multiple 
#' bootstrapped iterations of the function. This can later be used to analyze the performance of 
#' the ENA bootstrapping approach.
#' @param data the matrix of gene expression to reconstruct
#' @param the character representation of the function to use to reconstruct
#' @param iterations the number of iterations to bootstrap through
#' @param cluster the MPI cluster to use when bootstrapping
#' @param sample.percentage the percentage of total samples to use in each bootstrapped iteration.
single_vs_bootstrapped <- function(data, fun, iterations=500, cluster=NULL, sample.percentage = 0.7){
    funName <- fun
    fun <- get(fun)
    funWrapper <- function(rand.seed, fun, data, sample.percentage, 
        ...) {
        set.seed(rand.seed)
        sampledData <- data[, sample(1:ncol(data), round(sample.percentage * 
            ncol(data)))]
        net <- symmetricize(abs(fun(sampledData)))
        return(net[upper.tri(net)])
    }
    toReturn <- getTableAddressing(rownames(data), truth)
    if (!missing(cluster) && "MPIcluster" %in% class(cluster)) {
        clusterExport(cluster, c("symmetricize"))
        result <- clusterApplyLB(cluster, 1:iterations, funWrapper, 
            fun, data, sample.percentage)
    }
    else {
        result <- lapply(1:iterations, funWrapper, fun, data, 
            sample.percentage)
    }
    result <- as.data.frame(result)
    colnames(result) <- 1:iterations
    
    single <- symmetricize(abs(fun(data)))
    single <- single[upper.tri(single)]
    
    toReturn <- cbind(single, result)
    colnames(toReturn)[1] <- "Single"
        
    return(toReturn)
}
	

```

We can now define a handful of functions used in analyzing the AUC of the above function.

```{r}
library(ROCR)
#' Compute the AUC of the given data
#' @param truth a vector of binary truth values
#' @param predicted a vector of numeric prediction values.
getAUC <- function(truth, predicted){
  pred <- prediction(predicted, truth);
  auc <- performance(pred, "auc")@y.values[[1]];
  auc;
}

#' Compue the AUCs of all sequential ENA datasets in the provided data.frame
#' and return the AUCs.
#' @param mat the data.frame/matrix with each column representing a single 
#' iteration's resultant network and each row representing an edge in the
#' network.
#' @param truth a vector of binary truth values for each row in the provided
#' matrix.
compute_ena_aucs <- function(mat,truth){
	aucs <- NULL
	for (i in 1:ncol(mat)){
		if (i != 1){
			iter <- 1/((1/iter) + log(rank(-mat[,i]) + 1))
		} else{
			iter <- mat[,1]	
		}		
		aucs[i] <- getAUC(truth, iter)
	}
	aucs
}

#' Compute the compute_ena_aucs function on all three network reconstruction
#' techniques and return the diferences in the AUCs of each method.
#' @param data the expression data on which reconstruction will be applied
#' @param truth the binary truth matrix for this data
#' @param cluster the MPI cluster across which to distribute the work.
bootstrapNetwork <- function(data, truth, iterations, cluster=cluster){
	sp <- single_vs_bootstrapped(data, "buildSpace", iterations=iterations, cluster=cluster)
	spAUC <- getAUC(truth, sp$Single)
	spBoot <- compute_ena_aucs(sp[,-1], truth)
	
	wg <- single_vs_bootstrapped(data, "buildWgcna", iterations=iterations, cluster=cluster)
	wgAUC <- getAUC(truth, wg$Single)
	wgBoot <- compute_ena_aucs(wg[,-1], truth)
	
	gn <- single_vs_bootstrapped(data, "buildGenenet", iterations=iterations, cluster=cluster)
	gnAUC <- getAUC(truth, gn$Single)
	gnBoot <- compute_ena_aucs(gn[,-1], truth)
	
	results <- array(NA, dim=c(3, iterations), dimnames=list(Method=c("SPACE", "WGCNA", "GeneNet"), Iteration=1:iterations))
	
	results["SPACE",] <- spBoot - spAUC
	results["WGCNA",] <- wgBoot - wgAUC
	results["GeneNet",] <- gnBoot - gnAUC
	
	#note that you can use as.data.frame.table(results) to flatten these results
	#into a data.frame (i.e. for ggplotting.)
	
	results
}













SIZE <- c("tiny","small","moderate","middle","large")
NP <- as.character(c(20, 50, 100, 200, 500, 1000))
NOISE <- as.character(c(0.25, 0.5, 1, 1.5))
library(ENA)
library(GeneNet)
library(WGCNA)
library(space)














truthToMat <- function(IDs, truthList){
	truth <- matrix(0, ncol=length(IDs), nrow=length(IDs))
	rownames(truth) <- IDs
	colnames(truth) <- IDs
	diag(truth) <- 1;
	for (i in 1:dim(truthList)[1]){
		s <- truthList[i,]$Source
		t <- truthList[i,]$Target
		r <- truthList[i,]$regulation
		truth[which(IDs == s), which(IDs == t)] <- r
	}
	truth <- symmetricize(truth, "ud")
	return (truth)
}

#' Get a binary vector of truth for the given size corresponding to the upper
#' triangle of the dataset.
#' @param size one of "tiny", "small", "moderate", "middle", or "large"
getTruth <- function(size){
	truthList <- read.csv(paste("../truth/truth ", size, ".csv", sep=""));
	simul <- read.csv(paste("../data/simulations/",size, "nSamp", NP[1], "Sigma", NOISE[1], ".csv",sep=""), row.names=1)	
	truth <- truthToMat(rownames(simul), truthList)
	addr <- getTableAddressing(rownames(truth), truth)
	truth <- addr$Truth != 0
		
	truth		
}

#' Get the expression data fora particular network size, sample number, and 
#' noise value.
getExpression <- function(size, np, sigma){
	data <- read.csv(paste("../data/simulations/",size, "nSamp", np, "Sigma", sigma, ".csv",sep=""), row.names=1)	
	data
}
```

We can plot out a very thorough comparison of the difference between the single and bootstrapped methods.

```{r aucCalc}
iterations<-200
AUCs <- array(NA, dim=c(length(SIZE),length(NP), length(NOISE), 3, iterations), dimnames=list(Size=SIZE, Samples=NP, Sigma=NOISE, Method=c("SPACE", "WGCNA", "GeneNet"), 1:iterations))

cluster <- NULL
if (require(Rmpi) && require(snow)){
	invisible(capture.output(cluster <- makeCluster(mpi.universe.size()-1, type="MPI")))	
	warning(paste("Distributing bootstrapped networks across a cluster of", mpi.universe.size()-1, "CPUs."))
}

truth <- NULL
for (size in SIZE[1:4]){
	truth <- getTruth(size)
	for (np in NP){
		cat(np, "\n")
		for (sigma in NOISE){
			cat("\t", sigma, "\n")	
			
			thisNet <- bootstrapNetwork(getExpression(size, np, sigma), 
																	truth, 
																	iterations=iterations, 
																	cluster=cluster)
			
			AUCs[size, np, sigma,,] <- thisNet		
		}
	}
	saveRDS(AUCs, "AUCs.Rds")	
}
AUCtab <- as.data.frame.table(AUCs["small",,,,], responseName="AUC")
colnames(AUCtab)[4] <- "Iteration"
AUCtab$Iteration <- as.integer(as.character(AUCtab$Iteration))
```

```{r}
library(ggplot2)
ggplot(AUCtab, aes(Iteration, AUC, color=Method, group=Method)) + geom_point() +  facet_grid(Sigma ~ Samples) + geom_hline(aes(yintercept=0))
```
