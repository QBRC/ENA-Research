This section will compare the single execution of a networkreconstruction technique to a bootstrapped execution. The single execution will use all 100% of the samples in its construction, whereas the bootstrapped version will only use 70% each iteration.

We'll first define the function that will give us the resultant network from a single iteration of 100% and a series of smaller iterations at 70%.

```{r}
#' Create a data.frame storing one single iteration of the selecte method along with multiple 
#' bootstrapped iterations of the function. This can later be used to analyze the performance of 
#' the ENA bootstrapping approach.
#' @param data the matrix of gene expression to reconstruct
#' @param the character representation of the function to use to reconstruct
#' @param iterations the number of iterations to bootstrap through
#' @param cluster the MPI cluster to use when bootstrapping
#' @param sample.percentage the percentage of total samples to use in each bootstrapped iteration.
single_vs_bootstrapped <- function(data, fun, iterations=500, cluster=NULL, sample.percentage = 0.7){
    funName <- fun
    fun <- get(fun)
    funWrapper <- function(rand.seed, fun, data, sample.percentage, 
        ...) {
        set.seed(rand.seed)
        sampledData <- data[, sample(1:ncol(data), round(sample.percentage * 
            ncol(data)))]
        net <- symmetricize(abs(fun(sampledData)))
        return(net[upper.tri(net)])
    }
    toReturn <- getTableAddressing(rownames(data), truth)
    if (!missing(cluster) && "MPIcluster" %in% class(cluster)) {
        clusterExport(cluster, c("symmetricize"))
        result <- clusterApplyLB(cluster, 1:iterations, funWrapper, 
            fun, data, sample.percentage)
    }
    else {
        result <- lapply(1:iterations, funWrapper, fun, data, 
            sample.percentage)
    }
    result <- as.data.frame(result)
    colnames(result) <- 1:iterations
    
    single <- symmetricize(abs(fun(data)))
    single <- single[upper.tri(single)]
    
    toReturn <- cbind(single, result)
    colnames(toReturn)[1] <- "Single"
        
    return(toReturn)
}
	

```

We can now define a handful of functions used in analyzing the AUC of the above function.

```{r}
library(ROCR)
#' Compute the AUC of the given data
#' @param truth a vector of binary truth values
#' @param predicted a vector of numeric prediction values.
getAUC <- function(truth, predicted){
  pred <- prediction(predicted, truth);
  auc <- performance(pred, "auc")@y.values[[1]];
  auc;
}

#' Compue the AUCs of all sequential ENA datasets in the provided data.frame
#' and return the AUCs.
#' @param mat the data.frame/matrix with each column representing a single 
#' iteration's resultant network and each row representing an edge in the
#' network.
#' @param truth a vector of binary truth values for each row in the provided
#' matrix.
compute_ena_aucs <- function(mat,truth){
	aucs <- NULL
	for (i in 1:ncol(mat)){
		if (i != 1){
			iter <- 1/((1/iter) + log(rank(-mat[,i]) + 1))
		} else{
			iter <- mat[,1]	
		}		
		aucs[i] <- getAUC(truth, iter)
	}
	aucs
}

#' Compute the compute_ena_aucs function on all three network reconstruction
#' techniques and return the diferences in the AUCs of each method.
#' @param data the expression data on which reconstruction will be applied
#' @param truth the binary truth matrix for this data
bootstrapNetwork <- function(data, truth, iterations){
	sp <- single_vs_bootstrapped(data, "buildSpace", iterations=iterations)
	spAUC <- getAUC(truth, sp$Single)
	spBoot <- compute_ena_aucs(sp[,-1], truth)
	
	wg <- single_vs_bootstrapped(data, "buildWgcna", iterations=iterations)
	wgAUC <- getAUC(truth, wg$Single)
	wgBoot <- compute_ena_aucs(wg[,-1], truth)
	
	gn <- single_vs_bootstrapped(data, "buildGenenet", iterations=iterations)
	gnAUC <- getAUC(truth, gn$Single)
	gnBoot <- compute_ena_aucs(gn[,-1], truth)
	
	results <- array(NA, dim=c(3, iterations), dimnames=list(Method=c("SPACE", "WGCNA", "GeneNet"), Iteration=1:iterations))
	
	results["SPACE",] <- spBoot - spAUC
	results["WGCNA",] <- wgBoot - wgAUC
	results["GeneNet",] <- gnBoot - gnAUC
	
	#note that you can use as.data.frame.table(results) to flatten these results
	#into a data.frame (i.e. for ggplotting.)
	
	results
}

#' Get a binary vector of truth for the given size corresponding to the upper
#' triangle of the dataset.
#' @param size one of "tiny", "small", "moderate", "middle", or "large"
getTruth <- function(size){
	truthList <- read.csv(paste("../truth/truth ", size, ".csv", sep=""));
	simul <- read.csv(paste(dataDir,size, "nSamp", NP[1], "Sigma", NOISE[1], ".csv",sep=""), row.names=1)	
	truth <- truthToMat(rownames(simul), truthList)
	addr <- getTableAddressing(rownames(truth), truth)
	truth <- addr$Truth != 0
		
	truth		
}

#' Get the expression data fora particular network size, sample number, and 
#' noise value.
getExpression <- function(size, np, sigma){
	data <- read.csv(paste("../data/simulations/",size, "nSamp", ns, "Sigma", sigma, ".csv",sep=""), row.names=1)	
	data
}
```

```{r}
small100s05 <- bootstrapNetwork(getExpression("small", "100", "1.5"), getTruth("small"), iterations=150)
small100s05 <- transform(as.data.frame.table(small100s05, responseName="AUC"), Iteration=as.integer(as.character(Iteration)))

ggplot(small100s05, aes(Iteration, AUC, color=Method, group=Method)) + geom_line() + geom_hline(aes(yintercept=0))
```

