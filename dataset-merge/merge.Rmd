This section will test the reconstruction of three different datasets using a naive merging approach and a meta-analysis approach based on ENA.

First, we'll read in three simulated datasets.

```{r}
sim25 <- read.csv("../data/simulations/middlenSamp200Sigma0.25.csv", row.names=1)
sim5 <- read.csv("../data/simulations/middlenSamp200Sigma0.5.csv", row.names=1)
sim1 <- read.csv("../data/simulations/middlenSamp200Sigma1.csv", row.names=1)
```


```{r load, results='hide', message=FALSE}
library(WGCNA)
library(GeneNet)
library(space)
library(ENA)
library(ROCR)
```

We'll first need a function to extract the true network for inclusion in our aggregated tables.

```{r}
truthToMat <- function(IDs, truthList){
	truth <- matrix(0, ncol=length(IDs), nrow=length(IDs))
	rownames(truth) <- IDs
	colnames(truth) <- IDs
	diag(truth) <- 1;
	for (i in 1:dim(truthList)[1]){
		s <- truthList[i,]$Source
		t <- truthList[i,]$Target
		r <- truthList[i,]$regulation
		truth[which(IDs == s), which(IDs == t)] <- r
	}
	truth <- symmetricize(truth, "ud")
	return (truth)
}
```

We'll then need a helper function which, given all of the information about a simulation, can extract the simulated dataset, aggregate the results into a table, and write the output.

```{r processMatrices}
processMat <- function(simul, bootstrapCount=140, bootstrapPercentage = 0.7, cluster, truth){
	
	addressing <- getTableAddressing(rownames(simul), truth)
			
	sp <- bootstrap(simul, "buildSpace", cluster=cluster, iterations = bootstrapCount, sample.percentage = bootstrapPercentage)	
	wg <- symmetricize(abs(buildWgcna(simul)))
	wg <- wg[upper.tri(wg)]
	gn <- bootstrap(simul, "buildGenenet", cluster=cluster, iterations = bootstrapCount, sample.percentage = bootstrapPercentage)
			
	joint1 <- ena(cbind(gn[,3], wg, sp[,3]))
	joint1 <- data.frame(addressing, sp[,3], wg, gn[,3], joint1, row.names=NULL)
	colnames(joint1) <- c("Source", "Dest", "Truth", "BootstrappedSPACE", "WGCNA", "BootstrappedGenenet", "ENA")
	#Since this graph is undirected, for consistency, make Source always smaller than Dest
	allGenes <- union(joint1$Source, joint1$Dest)
	levels(joint1$Source) <- allGenes
	levels(joint1$Dest) <- allGenes
	joint1[as.character(joint1[,1]) > as.character(joint1[,2]),1:2] <- joint1[as.character(joint1[,1]) > as.character(joint1[,2]),2:1]
	
	return(joint1)
}
```
		
		
We'll want to grab the truth for this network:

```{r}
truthList <- read.csv(paste("../truth/truth middle.csv", sep=""));
truth <- truthToMat(rownames(sim1), truthList)

```
		
### Individual Network Reconstruction
		
We'll now reconstruct each of these networks individually.

```{r calcAUCs, message=FALSE, results='hide'}
cluster <- NULL
if (require(Rmpi) && require(snow)){
	invisible(capture.output(cluster <- makeCluster(mpi.universe.size()-1, type="MPI")))	
	warning(paste("Distributing bootstrapped networks across a cluster of", mpi.universe.size()-1, "CPUs."))
}
```

```{r}
net25 <- processMat(sim25, cluster=cluster, truth=truth)
net5 <- processMat(sim5, cluster=cluster, truth=truth)
net1 <- processMat(sim1, cluster=cluster, truth=truth)
```

### Merged Network Reconstruction

We'll now want to compute the merged networks using either the naive method or the meta-analysis ENA method. We'll perform the naive first by just stacking the three simulations on top of one another.

```{r}
stackedSim <- cbind(sim25, sim5, sim1)
stackedNet <- processMat(stackedSim, cluster=cluster, truth=truth)
```

And the alternative ENA method can be performed by joining the three previous results.

```{r}
enaNet <- ena(cbind(net25$ENA, net5$ENA, net1$ENA))

save(enaNet, stackedNet, net25, net5, net1, file="nets.Rda")
```

### Performance Review

We can now calculate the the ROCs/AUCs of these networks.

```{r}
truVec <- net25$Truth != 0
pred25 <- prediction(net25$ENA, truVec)
perf25 <- performance(pred25, "tpr", "fpr")
performance(pred25, "auc")@y.values[[1]]

pred5 <- prediction(net5$ENA, truVec)
perf5 <- performance(pred5, "tpr", "fpr")
performance(pred5, "auc")@y.values[[1]]

pred1 <- prediction(net1$ENA, truVec)
perf1 <- performance(pred1, "tpr", "fpr")
performance(pred1, "auc")@y.values[[1]]

predStac <- prediction(stackedNet$ENA, truVec)
perfStac <- performance(predStac, "tpr", "fpr")
performance(predStac, "auc")@y.values[[1]]

predENA <- prediction(enaNet, truVec)
perfENA <- performance(predENA, "tpr", "fpr")
performance(predENA, "auc")@y.values[[1]]
```

And plot them
```{r}
plot(perfENA, col=1, lwd=2)
plot(perfStac, col=2, lwd=2, add=TRUE)
plot(perf25, col=3, add=TRUE)
plot(perf5, col=4, add=TRUE)
plot(perf1, col=5, add=TRUE)
legend(.1, .4, 
			 c("ENA", 
			 	"Simple Merge", 
			 	expression(paste("Individual Network, ", sigma,"=0.25", sep="")), 
			 	expression(paste("Individual Network, ", sigma,"=0.5", sep="")), 
			 	expression(paste("Individual Network, ", sigma,"=1", sep=""))), col=1:5, lwd=c(2,2,1,1,1)) 
```









